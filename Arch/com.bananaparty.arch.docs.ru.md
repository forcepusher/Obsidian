# Архитектура "Спидран по контракту"
Поехали.
## Оглавление
Если что-то непонятно, скопипастите текст и попросите объяснить нейронку. Мы с ней друг друга хорошо понимаем. Пункты будут доработаны из TL;DR версии в полный трактат по запросу "пояснить за базар", если моя помощница не справилась.
- На философской части мы стабилизируем понимание слова "объект" и всего, что с ним связано, чтобы понять принятые решения и совершать меньше детских ошибок. Нельзя копировать чужое решение "просто потому что все так делают". Получится бессмыслица с костылями для решений несуществующих проблем.
- На практике мы нырнём сразу в дело и сделаем с помощью пары скриптов то, ради чего нормисы обычно несут в Unity проект несколько громоздких фреймворков с [граблями](https://github.com/modesttree/Zenject/blob/31f06cf81043f04301b1072ec81922b64149ea34/UnityProject/Assets/Plugins/Zenject/Source/Util/ZenUtilInternal.cs#L239), на которые уже не смешно наступать в 20-й раз.
- Так же будет блок по авто тестированию проектов. Никто вам не выделит целый отдел тестировщиков. Не у всех есть бюджет, чтоб закидать проблему деньгами.
## TL;DR: Спидран по философии объектов
Пазраб пишет хороший код в первые 2 года своей карьеры. Затем только через 10-15 лет.<br> <img src="media/linesperhourprogrammer.png" alt="Programmer XP Meme" width="600"><br>Чем быстрей вы выйдите из середины, тем проще будет жить вам и всем окружающим, поэтому я постараюсь ускорить процесс трансформации:
- Представьте, что объект это самостоятельная консольная программа. Из неё нельзя просто так достать чё хочешь и вертеть как хочешь, у неё есть свой интерфейс командной строки (CLI) для общения с программой (например как у Git в терминале). В нашем случае интерфейсом являются публичные методы класса, либо явно заданный интерфейс.<br>(Источник: [мой старый пост](https://forcepusher.tumblr.com/post/646953788143484928/my-take-on-explaining-oop-to-traditional))
- Объекты должны имплементировать одну фичу, S это не просто так первая буква в SOLID.
  Ещё объекты должны быть самодостаточными. По завершению исполнения конструктора, у объекта должны быть все необходимые данные и ссылки для исполнения своей задачи. В случае с Unity, конструктор это референсы/поля инспектора и Awake.<br>(Источник: Robert Martin, Егор Бугаенко, и я со своим Unity)
- Объект состоит из поведения и состояния. Если где-то что-то происходит, значит есть и объект, который это делает. Не бывает поведения в вакууме. Так же и не бывает объектов, которые состоят из одних только данных или состояния - это скорей просто структура. Поэтому деление слоёв на Model, View и Controller (либо другой MV*) это ошибка дизайна.<br>(Источники: [David West (Object Thinking)](https://www.youtube.com/watch?v=s-hdZZzMCac) и Егор Бугаенко)
- В правильном наименовании класса содержится 90% решения проблемы, это источник правильного мышления. Имя не должно быть излишне абстрактным, ненадо бояться точной конкретики. Не пытайтесь набить цену классу, продавая его умным названием. Если назвать дом хендлером жителей, то и делать будешь хендлер жителей, а не дом.<br>В ту же помойку Manager, Controller, Handler, Presenter и т.п.<br>(Источник: тоже я)
- Избегать названия объектов, образованных от глагола, оно должно оканчиваться существительным. Основной детектор ошибки это окончания -er. Например Loader, ну вот что за абстракции Загружатор, Расставлятор, Нагибатор? Объекты надо называть исходя из того что они содержат или чем по сути являются. Загружатор это название ни к чему не привязанного поведения. Найдите источник этого поведения и найдёте объект.<br>(Гигачады: Егор Бугаенко, [Peter Coad](https://en.wikipedia.org/wiki/Peter_Coad), [Carlo Pescio](https://www.carlopescio.com/2011/04/your-coding-conventions-are-hurting-you.html), [Travis Griggs](https://objology.blogspot.com/2011/09/one-of-best-bits-of-programming-advice.html), и [Ben Hall](https://web.archive.org/web/20130116152533/https://www.benhallbenhall.com/2013/01/naming-objects-er-object-names/). Этот пункт больше всего придаётся бугурту, но слишком много великих мыслителей включая меня заметили эту проблему, поэтому вам придётся с этим как-то жить)
## TL;DR: Волшебные скрипты для архитектуры в Unity
Если философия выше непонятна - ничего страшного, у нас есть волшебные ~~бобы~~ скрипты.
Каждый из скриптов решает точечно одну проблему, и доставать их из мешочка мы будем только тогда, когда проблема физически материализуется, вместо того чтоб бежать впереди паровоза и городить какую-то бесполезную херню заранее, пытаясь предугадать все правки, требования паблишеров, и давление мочевины в голове гейм дизайнера.<br><br>Вот наш набор скриптов [https://github.com/forcepusher/com.bananaparty.arch](https://github.com/forcepusher/com.bananaparty.arch)<br>Разберём типичные ситуации:
- Ситуация "Я хочу глобальные скрипты)))))0 а техлид говорит нельзя статику((((((((99".<br>Это прямо жиза. Короче, делаем префаб для глобальных скриптов, суём в него все наши любимые синглтоны (стирая из них все static Instance поля, либо отключая галку в ассетах).
  Берём [GlobalPrefabAsset.cs](https://github.com/forcepusher/com.bananaparty.arch/blob/288dbe6a0e7e225c48e257e833583992b4eb32ba/Runtime/GlobalPrefabAsset.cs), создаём в любой папке этот ScriptableObject, и суём в него наш глобальный префаб. Ну вот и всё, теперь у нас есть по сути GlobalContext из DI.
- Ситуация "Погоди браза, а как на этот GlobalContext теперь ссылаться то?".<br>Да легко, просто юзай FindObjectOfType. Шутка, но принцип работы у [ReferenceAsset.cs](https://github.com/forcepusher/com.bananaparty.arch/blob/288dbe6a0e7e225c48e257e833583992b4eb32ba/Runtime/ReferenceAsset.cs)тот же. Различие в том, что референсы в этот ScriptableObject мы забиваем заранее сами в рантайме, используя [ReferenceSource.cs](https://github.com/forcepusher/com.bananaparty.arch/blob/288dbe6a0e7e225c48e257e833583992b4eb32ba/Runtime/ReferenceSource.cs), который будет лежать рядом с компонентом.
  Та же самая стратегия когда ссылаемся что-то на сцене, аналогично SceneContext из DI.
- Ситуация "Ля, а давай бахнем FindObjectsOfType в апдейте?".<br>Эта же штука [ReferenceAsset.cs](https://github.com/forcepusher/com.bananaparty.arch/blob/288dbe6a0e7e225c48e257e833583992b4eb32ba/Runtime/ReferenceAsset.cs) покрывает все юзкейсы FindObject(s)OfType. Для множества объектов есть [ReferenceListAsset.cs](https://github.com/forcepusher/com.bananaparty.arch/blob/288dbe6a0e7e225c48e257e833583992b4eb32ba/Runtime/ReferenceListAsset.cs). Последнее часто нужно в создании ботов, чтобы передавать им что происходит на сцене. Естественно FindObjectsOfType станет главным ботлнеком производительности, не успеешь откыть и охоту крепкую.
- Ситуации "Давай сделаем спагетос из Eventов?" или "А давай шину бахнем?".<br>Максимально осуждаю, но даже такой флюгегехаймен для месье у нас найдётся.
  [EventHubAsset.cs](https://github.com/forcepusher/com.bananaparty.arch/blob/288dbe6a0e7e225c48e257e833583992b4eb32ba/Runtime/Events/EventHubAsset.cs) позволяет создавать ScriptableObject по аналогии с иструментами ранее, который будет хранить в себе ссылку на объект хранящий событие [EventHub.cs](https://github.com/forcepusher/com.bananaparty.arch/blob/288dbe6a0e7e225c48e257e833583992b4eb32ba/Runtime/Events/EventHub.cs). Однако это не просто событие, а [Fan-out](https://en.wikipedia.org/wiki/Fan-out_(software)) мессаджинг, который выдаёт каждому подписчику свою [EventQueue.cs](https://github.com/forcepusher/com.bananaparty.arch/blob/288dbe6a0e7e225c48e257e833583992b4eb32ba/Runtime/Events/EventQueue.cs) для ручного чтения, избегая [IoC](https://en.wikipedia.org/wiki/Inversion_of_control) спагетти. Это сильно упрощает дебаг, даёт возможность использования в логике ботов, и в мультипотоке.
- Бонусная ситуация "Не хочу ссылаться на сцену по стринге, я чё лох штоли?"<br>Одобряю. Держи браза [SceneReference.cs](https://github.com/forcepusher/com.bananaparty.arch/blob/288dbe6a0e7e225c48e257e833583992b4eb32ba/Runtime/SceneReference.cs).
## TL;DR: Как выжить без толпы тестировщиков
Тесты нужны, чтобы самому не играть в игру или протыкивать тестовую сцену каждый раз когда вносишь изменения. Оставьте кнопку Play впокое, нажмите Run Tests и подите налейте чайку. Это win-win штуковина для автоматизации рутины.<br>Одно дело когда разрабатываешь игру в соло и знаешь где что может сломаться, а другое когда ты не писал сам все части проекта и не знаешь чем чревато изменение кода который тебе надо поправить. В итоге ты либо ссышь и ничё не делаешь, либо делаешь и создаёшь баг, за который тебе прилетит по шапке. И попробуй докажи, что это не ты виноват, а техническое руководство, которое не позаботилось об интеграции тестов.<br>Да, и ради бога, не упарывайтесь в TDD. Вы не софт для авиа диспетчерской пишите. От вашего кода не зависят жизни, не надо кидаться из крайности в крайность.<br>
У нас есть 3 типа тестов:
- Unit Testing.
  Это когда тестируешь всего 1 метод одного изолированного объекта, или как принято говорить “1 юнит работы”. Формулировка действительно размыта.
- Integration Testing.<br>Это когда тестишь взаимодействие между несколькими отдельными объектами/системами/модулями. Тоже интерпретирует каждый как хочет.
- Play Testing.<br>А это когда попиваешь смузи и смотришь как игра играет саму в себя.<br>Оно не должно покрывать вообще всё. Достаточно тестов, которые дают понять, что игра в целом работает, и причинённый ущерб от твоих изменений минимален.

Нас конечно же интересует больше всего Play Testing. Первые 2 типа тестирования уже обсосаны всеми кому не лень. Сходите [Unity мануал](https://docs.unity3d.com/6000.2/Documentation/Manual/test-framework/test-framework-introduction.html) шоль почитайте.<br>Ладно, давайте приступим к мякотке:
- Описанные в этом документе архитектурные практики подразумевают полностью тестируемый код без статики. Помимо этого, [ReferenceAsset.cs](https://github.com/forcepusher/com.bananaparty.arch/blob/288dbe6a0e7e225c48e257e833583992b4eb32ba/Runtime/ReferenceAsset.cs) и [ReferenceSource.cs](https://github.com/forcepusher/com.bananaparty.arch/blob/288dbe6a0e7e225c48e257e833583992b4eb32ba/Runtime/ReferenceSource.cs) работают с интерфейсами, то есть в их генерику можно вбить любой интерфейс вроде IPepega и оно будет прекрасно работать. Это позволяет безболезненно писать тестовые моки для любых трёх типов тестов.
- Однако, если проект на какой-то дрисне, тоже ничего страшного. PlayTestы мы всё равно заведём. Всё что от вас нужно - это чтобы игра запускалась и нормально работала с любой игровой сцены. Для этого обычно нужно что-то вроде [GlobalPrefabAsset.cs](https://github.com/forcepusher/com.bananaparty.arch/blob/288dbe6a0e7e225c48e257e833583992b4eb32ba/Runtime/GlobalPrefabAsset.cs). Если использовать именно его, то глобальный префаб будет автоматом подгружаться в тест раннере. Это гигантский профит, но если вдруг нужно убрать его из тестов, заюзайте [IPrebuildSetup и IPostBuildCleanup](https://docs.unity3d.com/6000.2/Documentation/Manual/test-framework/course/build-setup-cleanup.html). Можно сделать галку-убиралку, сделаю по запросу.
<br>Варианты Play Test тестирования:
- Первый вариант это запуск сцены со скрипта и проверка на ней тестового сценария. Для этого у меня утилитка как раз есть [SceneListAsset.cs](https://github.com/forcepusher/com.bananaparty.arch/blob/288dbe6a0e7e225c48e257e833583992b4eb32ba/Runtime/TestingUtilities/SceneListAsset.cs), создайте SO и запихните в Resources в папке тестов, оттуда можно его подгрузить. Запускать мы будем не сцены сделанные для тестирования, а сцены, которые пойдут в прод, в саму игру. Чтобы сэкономить время можно даже подрубить ускорение по TimeScale во время теста.
- Второй вариант это 
- Что дальше? А продолжение следует. Для меня эта тема как и для вас довольно новая, но я толкаю телегу вперёд. Обычно используют всякие TeamCity, но тут как ни крути важна простота интеграции и использования для рядового сотрудника на аутсорсе, чего у TeamCity к сожалению нет. И я там был, мед, пиво пил, Да усы лишь обмочил.