# ООП по-пацански
[Живешь в России - ешь Антоновку](https://www.youtube.com/shorts/2cEWxYGsjlc)
## Оглавление
Если что-то непонятно, скопипастите текст и попросите объяснить нейронку. Мы с ней друг друга хорошо понимаем.
- На философской части мы стабилизируем понимание слова "объект" и всего, что с ним связано, чтобы понять принятые решения и совершать меньше детских ошибок. Нельзя копировать чужое решение "просто потому что все так делают". Получится бессмыслица с костылями для решений несуществующих проблем.
- Затем покроем вопрос "А как вообще код то писать?". Что делать когда накатывает архитектурный ступор и как не утонуть в чане со спагетти. Так же я расскажу почему ООП, внезапно, идеально ложиться на помойный код и радует начальника.
- Далее сделаем с помощью пары скриптов то, ради чего нормисы обычно несут в Unity проект несколько громоздких фреймворков с [граблями](https://github.com/modesttree/Zenject/blob/31f06cf81043f04301b1072ec81922b64149ea34/UnityProject/Assets/Plugins/Zenject/Source/Util/ZenUtilInternal.cs#L239), на которые уже не смешно наступать в 20-й раз.
- Так же будет блок по авто тестированию проектов. Никто вам не выделит целый отдел тестировщиков. Не у всех есть бюджет, чтоб закидать проблему деньгами.
## Спидран по философии объектов. Поехали
Разраб пишет хороший код в первые 2 года своей карьеры. Затем только через 10-15 лет.<br> <img src="media/linesperhourprogrammer.png" alt="Опыт программиста" width="600"/><br>Чем быстрей вы выйдите из середины, тем проще будет жить вам и всем окружающим, поэтому я постараюсь ускорить процесс трансформации:
- Представьте, что объект это самостоятельная консольная программа. Из неё нельзя просто так достать чё хочешь и вертеть как хочешь, у неё есть свой интерфейс командной строки (CLI) для общения с программой (например как у Git в терминале). В нашем случае интерфейсом являются публичные методы класса, либо явно заданный интерфейс.<br>(Источник: [мой старый пост](https://forcepusher.tumblr.com/post/646953788143484928/my-take-on-explaining-oop-to-traditional))
- Объекты должны имплементировать одну фичу, S это не просто так первая буква в SOLID.
  Ещё объекты должны быть самодостаточными. По завершению исполнения конструктора, у объекта должны быть все необходимые данные и ссылки для исполнения своей задачи. В случае с Unity, конструктор это референсы/поля инспектора и Awake.<br>(Источник: Robert Martin, Егор Бугаенко, и я со своим Unity)
- Объект состоит из поведения и состояния. Если где-то что-то происходит, значит есть и объект, который это делает. Не бывает поведения в вакууме. Так же и не бывает объектов, которые состоят из одних только данных или состояния - это скорей просто структура. Поэтому деление слоёв на Model, View и Controller (либо другой MV*) это ошибка дизайна.<br>(Источники: [David West (Object Thinking)](https://www.youtube.com/watch?v=s-hdZZzMCac) и Егор Бугаенко)
- В правильном наименовании класса содержится 90% решения проблемы, это источник правильного мышления. Имя не должно быть излишне абстрактным, ненадо бояться точной конкретики. Не пытайтесь набить цену классу, продавая его умным названием. Если назвать дом хендлером жителей, то и делать будешь хендлер жителей, а не дом.<br>В ту же помойку Manager, Controller, Handler, Presenter и т.п.<br>(Источник: тоже я)
- Избегать названия объектов, образованных от глагола, оно должно оканчиваться существительным. Основной детектор ошибки это окончания -er. Например Loader, ну вот что за абстракции Загружатор, Расставлятор, Нагибатор? Объекты надо называть исходя из того что они содержат или чем по сути являются. Загружатор это название ни к чему не привязанного поведения. Найдите источник этого поведения и найдёте объект.<br>Есть слова кончающиеся на -er, которые воспринимаются как самостоятельные понятие, вроде Сomputer и User. Однако подобных исключений немного.<br>(Гигачады: [Егор Бугаенко](https://www.yegor256.com/2015/03/09/objects-end-with-er.html), [Peter Coad](https://en.wikipedia.org/wiki/Peter_Coad), [Carlo Pescio](https://www.carlopescio.com/2011/04/your-coding-conventions-are-hurting-you.html), [Travis Griggs](https://objology.blogspot.com/2011/09/one-of-best-bits-of-programming-advice.html), и [Ben Hall](https://web.archive.org/web/20130116152533/https://www.benhallbenhall.com/2013/01/naming-objects-er-object-names/). Этот пункт больше всего придаётся бугурту, но слишком много народу включая меня заметили эту проблему, поэтому вам придётся с этим как-то жить)
- Наследование классов это не инструмент моделирования, это инструмент для реюза кода. Идея, что чайка наследуется от птицы, а птица летает - вкорне неправильная. Попросите пингвина объяснить на сколько это тупо. Чайка это чайка, просто она летать умеет. То есть, свойство "умеет летать" это интерфейс. К сожалению, расплодились агуши, которые везде орут "ООП говно", попавшись на детскую ошибку наследования.<br>(Источник: практически всё ООП коммунити, кроме [непонятых гениев](https://youtu.be/wo84LFzx5nI?t=6432))
- В одной из топ 5 мобильных студий нельзя кидать в коде Exception, потому что игра не должна крашиться и в игре не должно быть ошибок. После такого рассказа я аж забухал на неделю. Короче, кидайте Exception сразу, если в программе замечено неправильное поведение на стороне кода. Вы заметите ошибку сразу, а не будете ловить Silent Fail и снежный ком из заметённых под ковёр проблем.<br>Ещё раз, неправильное поведение на стороне кода - это не таймаут соединения от сдохшего вайфая. Ненадо Exceptionы кидать при ошибках соединения как это делают Microsoft в своих стандартных библиотеках.<br>(Источник: нагуглите [Fail-fast](https://en.wikipedia.org/wiki/Fail-fast_system), это очень народная концепция)
## Спидран по коду. Катаемся лицом по клавиатуре
Бизнес хочет быстрых результатов, поэтому нам придётся всё-таки подружиться с душными сущностями "Технический Долг" и "Грязный Код", а не яростно их устранять как [заведовал Дядя Боб]([Clean Coder - A Mess is not a Technical Debt.](https://sites.google.com/site/unclebobconsultingllc/a-mess-is-not-a-technical-debt)). Однако, писать грязный код это право, которое надо заслужить.<br>Если делать это без подготовки - утонешь в грязи, а код проекта целиком придётся взять и выкинуть вместе с собой из компании.<br><br>Как выжить в грязи:
- Ранее мы установили, что объекты это практически небольшая изолированная программа. И наше приложение состоит из композиции таких программ. То есть, когда мы над чем-то работает, мы пишем код для соединяем нескольких программ вместе, либо пишем саму программу.
- Если сами программы изолированные и выполняют какой-то контракт "это на входе, и вот это на выходе" с помощью методов, то нам плевать что в них написано, пока они дают корректный результат. То есть, критически важная часть это только код, который соединеняет эти программы вместе.
- Например, объект может содержать внутри кучу приватных костыльных полей с состоянием только ради того, чтоб всё правильно работало. А может обёртку чужих инструментов или даже целых систем - всё это можно потом безболезненно поменять. Можно хоть нейронный слоп туда сувать и не бояться кучи дерьма, которую напишет нейронка, до тех пор пока всё это удовольствие изолировано в объекте.

Круто да? Как же начальник обрадуется, что мы используем нейронный слоп в продакшне - "Будущее здесь", "Внедрение ИИ", "Оптимизация", "Программисты больше не нужны" и всё остальное что на уши понавешано. Вообще нейронки без модуля самообучения в реальном времени это не ИИ, до Шодан из System Shock нам пока далеко. Вот когда их научат учиться, а не просто расширять окно контекста, вот тогда уже достаём огнемёт.<br>Далее стиснем булки, нам предстоит взрослая работа, которую не сможет сделать автокомплит T9, или Google+, или как удобно это называть.<br><br>А теперь следи за руками:
- Писать код мы все умеем. Допустим есть задача. Сначала мы думаем как её решить, затем пишем придуманный алгоритм, затем вставляем вызов кода с нашим алгоритмом.<br>Вроде просто да? Ну вот именно поэтому у нас всегда получается херня.
- Сначала мы вставляем вызов кода с алгоритмом, которого пока нет. Проверяем, что сам вызов эфемерного алгоритма нас устраивает и он удобен в использовании. Яростно его переделываем пока не устроит. Получается обычно раза с третего-пятого. И потом уже только садимся писать сам алгоритм, или вообще схалявим нейронкой.
- А теперь прикинь что бы было, если бы мы работали по старой схеме напрямую, и переписывали бы всё вместе с алгоритмом 5 раз.<br>Подход "пиши с конца" это волшебная пуля для API дизайна и контрактов/интерфейсов объектов. Развитие навыка инвертированно мыслить будет ощущаться как переход из С++ на JavaScript, возможно будет температура и тошнота.

Ну теперь ты прямо боевой слон. Не спеши топтать грядки, надо ещё пару фишек прощупать.<br>Есть ещё такая штука как [Control Flow](https://en.wikipedia.org/wiki/Control_flow). Чтоб не читать всю портянку, вкратце скажу что код удобно читать, когда он исполняется строчка за строчкой сверху вниз, а не как попало.<br>Ну вроде база же, да? Окей, а почему у тебя тогда всё в событиях усыпано?
## Спидран по волшебным скриптам для Unity
Если философия объектов непонятна - ничего страшного, у нас есть волшебные скрипты.<br>Каждый из скриптов решает точечно одну проблему, и доставать их мы будем только тогда, когда проблема физически материализуется, вместо того чтоб бежать впереди паровоза и городить какую-то бесполезную херню заранее, пытаясь предугадать все правки, требования паблишеров, и изыски гейм дизайнера.<br><br>Вот наш набор скриптов [https://github.com/forcepusher/com.bananaparty.arch](https://github.com/forcepusher/com.bananaparty.arch)<br>И для него [пример](https://github.com/forcepusher/BananaArchDevRepo/tree/master/Assets/Source) и [видюшки](https://t.me/UnityWebGL/113) в камментах на посте в телеграмме. Проще 1 раз показать, чем 100 раз объяснить.<br>Разберём типичные ситуации:
- Ситуация "Я хочу глобальные скрипты))))0 а техлид говорит нельзя статику((((((99".<br>Это прямо жиза. Короче, делаем префаб для глобальных скриптов, суём в него все наши любимые синглтоны (стирая из них все static Instance поля, либо отключая галку в ассетах).
  Берём [GlobalPrefabAsset.cs](https://github.com/forcepusher/com.bananaparty.arch/blob/288dbe6a0e7e225c48e257e833583992b4eb32ba/Runtime/GlobalPrefabAsset.cs), создаём в любой папке этот ScriptableObject, и суём в него наш глобальный префаб. Ну вот и всё, теперь у нас есть по сути GlobalContext из DI.
- Ситуация "Погоди браза, а как на этот GlobalContext теперь ссылаться то?".<br>Да легко, просто юзай FindObjectOfType. Шутка, но принцип работы у [ReferenceAsset.cs](https://github.com/forcepusher/com.bananaparty.arch/blob/288dbe6a0e7e225c48e257e833583992b4eb32ba/Runtime/ReferenceAsset.cs) тот же. Различие в том, что референсы в этот ScriptableObject мы забиваем заранее сами в рантайме, используя [ReferenceSource.cs](https://github.com/forcepusher/com.bananaparty.arch/blob/288dbe6a0e7e225c48e257e833583992b4eb32ba/Runtime/ReferenceSource.cs), который будет лежать рядом с компонентом.
  Та же самая стратегия когда ссылаемся что-то на сцене, аналогично SceneContext из DI.
- Ситуация "Ля, а давай бахнем FindObjectsOfType в апдейте?".<br>Эта же штука [ReferenceAsset.cs](https://github.com/forcepusher/com.bananaparty.arch/blob/288dbe6a0e7e225c48e257e833583992b4eb32ba/Runtime/ReferenceAsset.cs) покрывает все юзкейсы FindObject(s)OfType. Для списка всех объектов есть [ReferenceListAsset.cs](https://github.com/forcepusher/com.bananaparty.arch/blob/288dbe6a0e7e225c48e257e833583992b4eb32ba/Runtime/ReferenceListAsset.cs). Последнее часто нужно в создании ботов, чтобы передавать им что происходит на сцене. Естественно FindObjectsOfType станет главным ботлнеком производительности, не успеешь откыть и охоту крепкую.
- Ситуации "Давай сделаем спагетос из Eventов?" или "А давай шину событий бахнем?".<br>Максимально осуждаю, но даже такой флюгегехаймен для месье у нас найдётся.
  [EventHubAsset.cs](https://github.com/forcepusher/com.bananaparty.arch/blob/288dbe6a0e7e225c48e257e833583992b4eb32ba/Runtime/Events/EventHubAsset.cs) позволяет создавать ScriptableObject по аналогии с иструментами ранее, который будет хранить в себе ссылку на объект с [EventHub.cs](https://github.com/forcepusher/com.bananaparty.arch/blob/288dbe6a0e7e225c48e257e833583992b4eb32ba/Runtime/Events/EventHub.cs). Однако это не просто событие, а [Fan-out](https://en.wikipedia.org/wiki/Fan-out_(software)) мессаджинг, который выдаёт каждому подписчику свою [EventQueue.cs](https://github.com/forcepusher/com.bananaparty.arch/blob/288dbe6a0e7e225c48e257e833583992b4eb32ba/Runtime/Events/EventQueue.cs) для ручного чтения, избегая [IoC](https://en.wikipedia.org/wiki/Inversion_of_control) спагетти. Это сильно упрощает дебаг, даёт возможность использования в логике ботов, и в мультипотоке.
- Бонусная ситуация "Почему Unity не сделали ссылки на сцену? Они вообще там живые?"<br>Одобряю. Держи браза [SceneReference.cs](https://github.com/forcepusher/com.bananaparty.arch/blob/288dbe6a0e7e225c48e257e833583992b4eb32ba/Runtime/SceneReference.cs).
## Спидран по выживанию без толпы тестировщиков
Тесты нужны, чтобы самому не играть в игру или протыкивать тестовую сцену каждый раз когда вносишь изменения. Оставьте кнопку Play впокое, нажмите Run Tests и подите налейте чайку. Это win-win штуковина для автоматизации рутины.<br>Одно дело когда разрабатываешь игру в соло и знаешь где что может сломаться, а другое когда ты не писал сам все части проекта и не знаешь чем чревато изменение кода который тебе надо поменять. В итоге ты либо ссышь и ничё не делаешь, либо делаешь и создаёшь баг, за который тебе прилетит по шапке. И попробуй докажи, что это не ты виноват, а техническое руководство, которое не позаботилось об интеграции тестов.<br><br>Важное замечание, что результат тестов нужен сразу после изменения кода здесь и сейчас, а не после заливки на гит. Не стоит молиться на всякие TeamCity, локальных тестов оно никак не сможет заменить. Это скорей вахтёрская штука, которая проверяет, что тот кто пушит в транк (например develop) действительно запускал у себя тесты.<br>Да, и ради бога, не упарывайтесь в TDD. Вы не софт для авиа диспетчерской пишите. От вашего кода не зависят жизни, не надо кидаться из крайности в крайность.<br><br>Так вот, у нас есть 3 типа тестов:
- Unit Testing.<br>Это когда тестируешь всего 1 метод одного изолированного объекта, или как принято говорить “1 юнит работы”. Формулировка действительно размыта.
- Integration Testing.<br>Это когда тестишь взаимодействие между несколькими отдельными объектами/системами/модулями. Тоже интерпретирует каждый как хочет.
- Play Testing.<br>Когда попиваешь смузи и смотришь как игра играет саму в себя (это [я сам придумал](https://www.youtube.com/watch?v=98pqX87e6Q4)).<br>Оно не должно покрывать вообще всё. Достаточно тестов, которые дают понять, что игра в целом работает, и причинённый ущерб от ваших изменений минимален, если он есть. Полтора калеки-тестировщика это отловят как-нибудь.

Нас конечно же интересует больше всего Play Testing. Эта двоица Unit и Integration Testing уже обсосаны всеми кому не лень. Как минимум [Unity мануал](https://docs.unity3d.com/6000.2/Documentation/Manual/test-framework/test-framework-introduction.html) можно почитать.<br>Давайте приступим к мякотке:
- Описанные в этом документе архитектурные практики подразумевают полностью тестируемый код без статики. Помимо этого, [ReferenceAsset.cs](https://github.com/forcepusher/com.bananaparty.arch/blob/288dbe6a0e7e225c48e257e833583992b4eb32ba/Runtime/ReferenceAsset.cs) и [ReferenceSource.cs](https://github.com/forcepusher/com.bananaparty.arch/blob/288dbe6a0e7e225c48e257e833583992b4eb32ba/Runtime/ReferenceSource.cs) работают с интерфейсами, то есть в их генерику можно вбить любой интерфейс вроде IPepega и оно будет прекрасно работать. Это позволяет безболезненно писать тестовые моки для любых трёх типов тестов.
- Однако, в силу человеческой природы, архитектуру всегда диктует самый громкий, харизматичный и бестолковый член вашей команды. Ничего страшного, PlayTestы мы всё равно заведём. Всё что от вас нужно - это чтобы игра запускалась и нормально работала с любой игровой сцены. Для этого обычно нужно что-то вроде [GlobalPrefabAsset.cs](https://github.com/forcepusher/com.bananaparty.arch/blob/288dbe6a0e7e225c48e257e833583992b4eb32ba/Runtime/GlobalPrefabAsset.cs). Если использовать именно его, то глобальный префаб будет автоматом подгружаться в тест раннере. Это гигантский профит, но если вдруг нужно убрать его из тестов, заюзайте [IPrebuildSetup и IPostBuildCleanup](https://docs.unity3d.com/6000.2/Documentation/Manual/test-framework/course/build-setup-cleanup.html).

Варианты Play Test тестирования:
- Первый вариант это запуск сцен со скрипта и проверка на них тестового сценария. Для этого у меня утилитка как раз есть [SceneListAsset.cs](https://github.com/forcepusher/com.bananaparty.arch/blob/288dbe6a0e7e225c48e257e833583992b4eb32ba/Runtime/TestingUtilities/SceneListAsset.cs), создайте SO и запихните в Resources в папке тестов, оттуда можно его подгрузить. Запускать мы будем не сцены сделанные для тестирования, а сцены, которые пойдут в прод, в саму игру. Чтобы сэкономить время можно даже подрубить ускорение по TimeScale во время теста.
- Второй вариант это старт игры с самой первой сцены и протыкивание кнопок скриптом для прохождения игры. Названия кнопок можно вбить в какой-нить [StringListAsset.cs](https://github.com/forcepusher/com.bananaparty.arch/blob/288dbe6a0e7e225c48e257e833583992b4eb32ba/Runtime/TestingUtilities/StringListAsset.cs), тыкать их поочереди и проверять по какому-нибудь легко-проверяемому признаку сработала ли кнопка. Да кстати, есть баг в тест раннере с индексами сцен, поэтому чтоб загрузить первую сцену надо юзать вот это [TestRunnerApplication.cs](https://github.com/forcepusher/com.bananaparty.arch/blob/288dbe6a0e7e225c48e257e833583992b4eb32ba/Runtime/TestingUtilities/TestRunnerApplication.cs#L5) (нифигасебе, я создал метод, который возвращает единицу или нолик).

Ну как-то так, буду обновлять по мере поступления вопросов, комментариев и инфоповодов. В нас кинули ООП - самый сложный инструмент, который есть в программировании, и сказали разбираться самим. Ну и ладно, разберёмся как-нибудь. Я на это убил 15 лет - но ничё страшного, йоло и всё такое.
