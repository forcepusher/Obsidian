# ООП без умных слов на Unity
[Живешь в России - ешь Антоновку](https://www.youtube.com/shorts/2cEWxYGsjlc)
## Оглавление
Если что-то непонятно, скопипастите текст и попросите объяснить нейронку. Мы с ней друг друга хорошо понимаем.
- На философской части мы стабилизируем понимание слова "объект" и всего, что с ним связано, чтобы понять принятые решения и совершать меньше детских ошибок. Нельзя копировать чужое решение "просто потому что все так делают". Получится бессмыслица с костылями для решений несуществующих проблем.
- На практике мы нырнём сразу в дело и сделаем с помощью пары скриптов то, ради чего нормисы обычно несут в Unity проект несколько громоздких фреймворков с [граблями](https://github.com/modesttree/Zenject/blob/31f06cf81043f04301b1072ec81922b64149ea34/UnityProject/Assets/Plugins/Zenject/Source/Util/ZenUtilInternal.cs#L239), на которые уже не смешно наступать в 20-й раз.
- Так же будет блок по авто тестированию проектов. Никто вам не выделит целый отдел тестировщиков. Не у всех есть бюджет, чтоб закидать проблему деньгами.
## Спидран по философии объектов. Поехали
Разраб пишет хороший код в первые 2 года своей карьеры. Затем только через 10-15 лет.<br> <img src="media/linesperhourprogrammer.png" alt="Опыт программиста" width="600"/><br>Чем быстрей вы выйдите из середины, тем проще будет жить вам и всем окружающим, поэтому я постараюсь ускорить процесс трансформации:
- Представьте, что объект это самостоятельная консольная программа. Из неё нельзя просто так достать чё хочешь и вертеть как хочешь, у неё есть свой интерфейс командной строки (CLI) для общения с программой (например как у Git в терминале). В нашем случае интерфейсом являются публичные методы класса, либо явно заданный интерфейс.<br>(Источник: [мой старый пост](https://forcepusher.tumblr.com/post/646953788143484928/my-take-on-explaining-oop-to-traditional))
- Объекты должны имплементировать одну фичу, S это не просто так первая буква в SOLID.
  Ещё объекты должны быть самодостаточными. По завершению исполнения конструктора, у объекта должны быть все необходимые данные и ссылки для исполнения своей задачи. В случае с Unity, конструктор это референсы/поля инспектора и Awake.<br>(Источник: Robert Martin, Егор Бугаенко, и я со своим Unity)
- Объект состоит из поведения и состояния. Если где-то что-то происходит, значит есть и объект, который это делает. Не бывает поведения в вакууме. Так же и не бывает объектов, которые состоят из одних только данных или состояния - это скорей просто структура. Поэтому деление слоёв на Model, View и Controller (либо другой MV*) это ошибка дизайна.<br>(Источники: [David West (Object Thinking)](https://www.youtube.com/watch?v=s-hdZZzMCac) и Егор Бугаенко)
- В правильном наименовании класса содержится 90% решения проблемы, это источник правильного мышления. Имя не должно быть излишне абстрактным, ненадо бояться точной конкретики. Не пытайтесь набить цену классу, продавая его умным названием. Если назвать дом хендлером жителей, то и делать будешь хендлер жителей, а не дом.<br>В ту же помойку Manager, Controller, Handler, Presenter и т.п.<br>(Источник: тоже я)
- Избегать названия объектов, образованных от глагола, оно должно оканчиваться существительным. Основной детектор ошибки это окончания -er. Например Loader, ну вот что за абстракции Загружатор, Расставлятор, Нагибатор? Объекты надо называть исходя из того что они содержат или чем по сути являются. Загружатор это название ни к чему не привязанного поведения. Найдите источник этого поведения и найдёте объект.<br>(Гигачады: Егор Бугаенко, [Peter Coad](https://en.wikipedia.org/wiki/Peter_Coad), [Carlo Pescio](https://www.carlopescio.com/2011/04/your-coding-conventions-are-hurting-you.html), [Travis Griggs](https://objology.blogspot.com/2011/09/one-of-best-bits-of-programming-advice.html), и [Ben Hall](https://web.archive.org/web/20130116152533/https://www.benhallbenhall.com/2013/01/naming-objects-er-object-names/). Этот пункт больше всего придаётся бугурту, но слишком много "великих мыслителей" включая меня заметили эту проблему, поэтому вам придётся с этим как-то жить)
- Наследование классов это не инструмент моделирования, это инструмент для реюза кода. Идея, что чайка наследуется от птицы, а птица летает - вкорне неправильная. Попросите пингвина объяснить на сколько это тупо. Чайка это чайка, просто она летать умеет. То есть, свойство "умеет летать" это интерфейс. К сожалению, расплодились агуши, которые везде орут "ООП говно", попавшись на детскую ошибку наследования.<br>(Источник: практически всё ООП коммунити, кроме [непонятых гениев](https://youtu.be/wo84LFzx5nI?t=6432))
- В одной из топ 5 мобильных студий нельзя кидать в коде Exception, потому что игра не должна крашиться и в игре не должно быть ошибок. После такого рассказа я аж забухал на неделю. Короче, не будьте маслятами, кидайте Exception сразу, если в программе замечено неправильное поведение на стороне кода. Вы заметите ошибку сразу, а не будете ловить Silent Fail и снежный ком из заметённых под ковёр проблем.<br>Ещё раз, неправильное поведение на стороне кода - это не таймаут соединения от сдохшего вайфая. Ненадо Exceptionы хреначить при ошибках соединения как это делают Microsoft в своих стандартных сетевых библиотеках.<br>(Источник: нагуглите [Fail-fast](https://en.wikipedia.org/wiki/Fail-fast_system), это очень народная концепция)
## Спидран по волшебным скриптам для Unity
Если философия выше непонятна - ничего страшного, у нас есть волшебные ~~бобы~~ скрипты.
Каждый из скриптов решает точечно одну проблему, и доставать их из мешочка мы будем только тогда, когда проблема физически материализуется, вместо того чтоб бежать впереди паровоза и городить какую-то бесполезную херню заранее, пытаясь предугадать все правки, требования паблишеров, и давление мочевины в голове гейм дизайнера.<br><br>Вот наш набор скриптов [https://github.com/forcepusher/com.bananaparty.arch](https://github.com/forcepusher/com.bananaparty.arch)<br>И для него [пример](https://github.com/forcepusher/BananaArchDevRepo/tree/master/Assets/Source) и [видюшки](https://t.me/UnityWebGL/113) в камментах на посте в телеграмме. Проще 1 раз показать, чем 100 раз объяснить.<br>Разберём типичные ситуации:
- Ситуация "Я хочу глобальные скрипты)))))0 а техлид говорит нельзя статику((((((((99".<br>Это прямо жиза. Короче, делаем префаб для глобальных скриптов, суём в него все наши любимые синглтоны (стирая из них все static Instance поля, либо отключая галку в ассетах).
  Берём [GlobalPrefabAsset.cs](https://github.com/forcepusher/com.bananaparty.arch/blob/288dbe6a0e7e225c48e257e833583992b4eb32ba/Runtime/GlobalPrefabAsset.cs), создаём в любой папке этот ScriptableObject, и суём в него наш глобальный префаб. Ну вот и всё, теперь у нас есть по сути GlobalContext из DI.
- Ситуация "Погоди браза, а как на этот GlobalContext теперь ссылаться то?".<br>Да легко, просто юзай FindObjectOfType. Шутка, но принцип работы у [ReferenceAsset.cs](https://github.com/forcepusher/com.bananaparty.arch/blob/288dbe6a0e7e225c48e257e833583992b4eb32ba/Runtime/ReferenceAsset.cs) тот же. Различие в том, что референсы в этот ScriptableObject мы забиваем заранее сами в рантайме, используя [ReferenceSource.cs](https://github.com/forcepusher/com.bananaparty.arch/blob/288dbe6a0e7e225c48e257e833583992b4eb32ba/Runtime/ReferenceSource.cs), который будет лежать рядом с компонентом.
  Та же самая стратегия когда ссылаемся что-то на сцене, аналогично SceneContext из DI.
- Ситуация "Ля, а давай бахнем FindObjectsOfType в апдейте?".<br>Эта же штука [ReferenceAsset.cs](https://github.com/forcepusher/com.bananaparty.arch/blob/288dbe6a0e7e225c48e257e833583992b4eb32ba/Runtime/ReferenceAsset.cs) покрывает все юзкейсы FindObject(s)OfType. Для списка всех объектов есть [ReferenceListAsset.cs](https://github.com/forcepusher/com.bananaparty.arch/blob/288dbe6a0e7e225c48e257e833583992b4eb32ba/Runtime/ReferenceListAsset.cs). Последнее часто нужно в создании ботов, чтобы передавать им что происходит на сцене. Естественно FindObjectsOfType станет главным ботлнеком производительности, не успеешь откыть и охоту крепкую.
- Ситуации "Давай сделаем спагетос из Eventов?" или "А давай шину событий бахнем?".<br>Максимально осуждаю, но даже такой флюгегехаймен для месье у нас найдётся.
  [EventHubAsset.cs](https://github.com/forcepusher/com.bananaparty.arch/blob/288dbe6a0e7e225c48e257e833583992b4eb32ba/Runtime/Events/EventHubAsset.cs) позволяет создавать ScriptableObject по аналогии с иструментами ранее, который будет хранить в себе ссылку на объект с [EventHub.cs](https://github.com/forcepusher/com.bananaparty.arch/blob/288dbe6a0e7e225c48e257e833583992b4eb32ba/Runtime/Events/EventHub.cs). Однако это не просто событие, а [Fan-out](https://en.wikipedia.org/wiki/Fan-out_(software)) мессаджинг, который выдаёт каждому подписчику свою [EventQueue.cs](https://github.com/forcepusher/com.bananaparty.arch/blob/288dbe6a0e7e225c48e257e833583992b4eb32ba/Runtime/Events/EventQueue.cs) для ручного чтения, избегая [IoC](https://en.wikipedia.org/wiki/Inversion_of_control) спагетти. Это сильно упрощает дебаг, даёт возможность использования в логике ботов, и в мультипотоке.
- Бонусная ситуация "Не хочу ссылаться на сцену по стринге, я чё лох шоли?"<br>Одобряю. Держи браза [SceneReference.cs](https://github.com/forcepusher/com.bananaparty.arch/blob/288dbe6a0e7e225c48e257e833583992b4eb32ba/Runtime/SceneReference.cs).
## Спидран по выживанию без толпы тестировщиков
Тесты нужны, чтобы самому не играть в игру или протыкивать тестовую сцену каждый раз когда вносишь изменения. Оставьте кнопку Play впокое, нажмите Run Tests и подите налейте чайку. Это win-win штуковина для автоматизации рутины.<br>Одно дело когда разрабатываешь игру в соло и знаешь где что может сломаться, а другое когда ты не писал сам все части проекта и не знаешь чем чревато изменение кода который тебе надо поменять. В итоге ты либо ссышь и ничё не делаешь, либо делаешь и создаёшь баг, за который тебе прилетит по шапке. И попробуй докажи, что это не ты виноват, а техническое руководство, которое не позаботилось об интеграции тестов.<br><br>Важное замечание, что результат тестов нужен сразу после изменения кода здесь и сейчас, а не после заливки на гит. Не стоит молиться на всякие TeamCity, локальных тестов оно никак не сможет заменить. Это скорей вахтёрская штука, которая проверяет, что тот кто пушит в транк (например develop) действительно запускал у себя тесты.<br>Да, и ради бога, не упарывайтесь в TDD. Вы не софт для авиа диспетчерской пишите. От вашего кода не зависят жизни, не надо кидаться из крайности в крайность.<br><br>Так вот, у нас есть 3 типа тестов:
- Unit Testing.<br>Это когда тестируешь всего 1 метод одного изолированного объекта, или как принято говорить “1 юнит работы”. Формулировка действительно размыта.
- Integration Testing.<br>Это когда тестишь взаимодействие между несколькими отдельными объектами/системами/модулями. Тоже интерпретирует каждый как хочет.
- Play Testing.<br>Когда попиваешь смузи и смотришь как игра играет саму в себя (это [я сам придумал](https://www.youtube.com/watch?v=98pqX87e6Q4)).<br>Оно не должно покрывать вообще всё. Достаточно тестов, которые дают понять, что игра в целом работает, и причинённый ущерб от ваших изменений минимален, если он есть. Полтора инвалида-тестировщика это отловят как-нибудь.

Нас конечно же интересует больше всего Play Testing. Эта двоица Unit и Integration Testing уже обсосаны всеми кому не лень. Сходите [Unity мануал](https://docs.unity3d.com/6000.2/Documentation/Manual/test-framework/test-framework-introduction.html) шоль почитайте.<br>Давайте приступим к мякотке:
- Описанные в этом документе архитектурные практики подразумевают полностью тестируемый код без статики. Помимо этого, [ReferenceAsset.cs](https://github.com/forcepusher/com.bananaparty.arch/blob/288dbe6a0e7e225c48e257e833583992b4eb32ba/Runtime/ReferenceAsset.cs) и [ReferenceSource.cs](https://github.com/forcepusher/com.bananaparty.arch/blob/288dbe6a0e7e225c48e257e833583992b4eb32ba/Runtime/ReferenceSource.cs) работают с интерфейсами, то есть в их генерику можно вбить любой интерфейс вроде IPepega и оно будет прекрасно работать. Это позволяет безболезненно писать тестовые моки для любых трёх типов тестов.
- Однако, если проект на какой-то дрисне, тоже ничего страшного. PlayTestы мы всё равно заведём. Всё что от вас нужно - это чтобы игра запускалась и нормально работала с любой игровой сцены. Для этого обычно нужно что-то вроде [GlobalPrefabAsset.cs](https://github.com/forcepusher/com.bananaparty.arch/blob/288dbe6a0e7e225c48e257e833583992b4eb32ba/Runtime/GlobalPrefabAsset.cs). Если использовать именно его, то глобальный префаб будет автоматом подгружаться в тест раннере. Это гигантский профит, но если вдруг нужно убрать его из тестов, заюзайте [IPrebuildSetup и IPostBuildCleanup](https://docs.unity3d.com/6000.2/Documentation/Manual/test-framework/course/build-setup-cleanup.html). Можно сделать галку-убиралку, сделаю по запросу.

Варианты Play Test тестирования:
- Первый вариант это запуск сцен со скрипта и проверка на них тестового сценария. Для этого у меня утилитка как раз есть [SceneListAsset.cs](https://github.com/forcepusher/com.bananaparty.arch/blob/288dbe6a0e7e225c48e257e833583992b4eb32ba/Runtime/TestingUtilities/SceneListAsset.cs), создайте SO и запихните в Resources в папке тестов, оттуда можно его подгрузить. Запускать мы будем не сцены сделанные для тестирования, а сцены, которые пойдут в прод, в саму игру. Чтобы сэкономить время можно даже подрубить ускорение по TimeScale во время теста.
- Второй вариант это старт игры с самой первой сцены и протыкивание кнопок скриптом для прохождения игры. Названия кнопок можно вбить в какой-нить [StringListAsset.cs](https://github.com/forcepusher/com.bananaparty.arch/blob/288dbe6a0e7e225c48e257e833583992b4eb32ba/Runtime/TestingUtilities/StringListAsset.cs), тыкать их поочереди и проверять по какому-нибудь легко-проверяемому признаку сработала ли кнопка. Да кстати, есть баг в тест раннере с индексами сцен, поэтому чтоб загрузить первую сцену надо юзать вот это [TestRunnerApplication.cs](https://github.com/forcepusher/com.bananaparty.arch/blob/288dbe6a0e7e225c48e257e833583992b4eb32ba/Runtime/TestingUtilities/TestRunnerApplication.cs#L5) (нифигасебе, я создал метод, который возвращает единицу или нолик).

Ну как-то так, буду обновлять по мере поступления вопросов, комментариев и инфоповодов. В нас кинули самый сложный инструмент, который есть в программировании (ООП), и сказали разбираться самим. Ну и ладно, разберёмся как-нибудь. Однако я на это убил 15 лет - но ничё страшного, йоло и всё такое.
